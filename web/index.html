<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ごろごろ将棋 (5x6)</title>
  <style>
    :root {
      --wood: #f2d696;
      --border: #5c4424;
      --highlight: #87cefa;
      --drop: #ff9800;
      --text: #2d1b0e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 20px;
      font-family: "Hiragino Sans", "Yu Gothic", sans-serif;
      background: radial-gradient(circle at 20% 20%, #fffaf0, #f0e6d0);
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      user-select: none;
      -webkit-user-drag: none;
    }
    h1 {
      margin: 0;
      font-size: 24px;
      letter-spacing: 0.05em;
    }
    #main-layout {
      display: flex;
      gap: 20px;
      align-items: flex-start;
      justify-content: center;
      flex-wrap: wrap;
      width: min(100%, 900px);
    }
    #record-panel {
      width: 200px;
      background: #f7e6c1;
      border: 2px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    }
    .panel-title {
      font-size: 14px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 6px;
      color: #5e3a12;
    }
    #history-wrapper {
      max-height: 420px;
      overflow-y: auto;
    }
    #history-list {
      list-style: decimal;
      list-style-position: inside;
      margin: 0;
      padding-left: 18px;
      font-size: 14px;
    }
    #history-list li {
      padding: 4px;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.6);
    }
    #history-list li.active {
      background: #ffe2b6;
      font-weight: bold;
      border: 1px solid rgba(0,0,0,0.15);
    }
    #history-list li + li {
      margin-top: 4px;
    }
    #history-empty {
      text-align: center;
      font-size: 13px;
      color: #7a6644;
      padding: 8px 0;
    }
    .history-controls {
      margin-top: 8px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
    }
    .history-controls button {
      font-size: 12px;
      padding: 6px 0;
    }
    #review-status {
      margin-top: 4px;
      font-size: 12px;
      text-align: center;
      min-height: 18px;
      color: #6b4a1c;
    }
    #review-status.active {
      font-weight: bold;
      color: #c0392b;
    }
    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    .hand {
      width: 320px;
      min-height: 60px;
      background: #e8d0a9;
      border: 2px solid var(--border);
      display: flex;
      flex-wrap: wrap;
      padding: 6px;
      gap: 6px;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
    }
    .hand-label {
      width: 100%;
      font-size: 12px;
      text-align: center;
      color: #5e3a12;
      border-bottom: 1px solid var(--border);
      margin-bottom: 2px;
      padding-bottom: 2px;
      pointer-events: none;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(5, 64px);
      grid-template-rows: repeat(6, 64px);
      border: 2px solid #333;
      background: var(--wood);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .cell {
      width: 64px;
      height: 64px;
      border: 1px solid #555;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      transition: background-color 0.15s ease;
    }
    .cell.selected { background: var(--highlight); }
    .cell.valid::after {
      content: "";
      position: absolute;
      width: 14px;
      height: 14px;
      background: rgba(255, 0, 0, 0.45);
      border-radius: 50%;
    }
    .cell.drag-over {
      background: #ffeb3b;
      border-color: var(--drop);
    }
    .piece {
      width: 54px;
      height: 54px;
      background: #ffefc0;
      border: 1px solid #8b5a2b;
      border-bottom: 3px solid #8b5a2b;
      border-radius: 6px 6px 16px 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 26px;
      font-weight: bold;
      color: #000;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
      cursor: grab;
      transition: transform 0.1s ease;
    }
    .piece:active { cursor: grabbing; }
    .piece.gote { transform: rotate(180deg); }
    .piece.promoted { color: #d00; }
    .hand-piece { min-width: 60px; justify-content: space-between; padding: 0 8px; cursor: pointer; }
    .hand-piece .count { font-size: 12px; }
    .piece.selected-hand { background: var(--highlight); border-color: #0056b3; }
    #status {
      font-weight: bold;
      font-size: 16px;
    }
    #message {
      min-height: 18px;
      color: #c00;
      font-size: 14px;
    }
    .controls {
      display: flex;
      gap: 8px;
    }
    .controls label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
    }
    select {
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fffef6;
      font-size: 14px;
    }
    button {
      padding: 8px 14px;
      font-size: 14px;
      cursor: pointer;
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
    #training-panel {
      width: min(100%, 900px);
      background: #fffaf2;
      border: 2px solid var(--border);
      border-radius: 10px;
      padding: 12px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.15);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    #training-panel h2 {
      margin: 0;
      font-size: 18px;
      color: #5e3a12;
    }
    .training-form {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 10px;
    }
    .training-form label {
      display: flex;
      flex-direction: column;
      font-size: 13px;
      color: #5e3a12;
      gap: 4px;
    }
    .training-form input,
    .training-form select {
      padding: 6px 8px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fff;
      font-size: 14px;
    }
    .training-actions {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items: center;
    }
    #training-summary {
      font-size: 14px;
      font-weight: bold;
      color: #5e3a12;
      min-height: 18px;
    }
    #training-message {
      min-height: 16px;
      font-size: 13px;
      color: #b03a2e;
    }
    #training-games-list {
      display: flex;
      flex-direction: column;
      gap: 6px;
      max-height: 220px;
      overflow-y: auto;
    }
    .training-game-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid rgba(0,0,0,0.15);
      background: rgba(255,255,255,0.8);
      font-size: 13px;
      gap: 12px;
      cursor: pointer;
      transition: box-shadow 0.15s ease, border-color 0.15s ease;
    }
    .training-game-row.running { border-color: #3498db; }
    .training-game-row.completed { border-color: #2ecc71; }
    .training-game-row.error { border-color: #e74c3c; }
    .training-game-row.aborted { border-color: #f39c12; }
    .training-game-row.active {
      box-shadow: 0 0 0 2px rgba(211,84,0,0.35) inset;
    }
    .training-game-id { font-weight: bold; }
    .training-config-note { font-size: 12px; color: #6b4a1c; }
    #training-viewer {
      border: 1px solid rgba(0,0,0,0.2);
      border-radius: 8px;
      padding: 10px;
      background: #fff7e1;
    }
    .training-viewer-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-weight: bold;
      font-size: 14px;
      color: #5e3a12;
    }
    #training-viewer-status {
      min-height: 18px;
      font-size: 13px;
      color: #6b4a1c;
    }
    #training-viewer-body {
      display: none;
    }
    #training-viewer-meta {
      font-size: 13px;
      margin: 6px 0;
      color: #5c4424;
    }
    .training-viewer-board-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }
    #training-viewer-board {
      display: grid;
      grid-template-columns: repeat(5, 48px);
      grid-template-rows: repeat(6, 48px);
      border: 1px solid #333;
      background: var(--wood);
      box-shadow: inset 0 2px 6px rgba(0,0,0,0.2);
    }
    #training-viewer-board .cell {
      width: 48px;
      height: 48px;
    }
    #training-viewer-board .piece {
      width: 40px;
      height: 40px;
      font-size: 20px;
      cursor: default;
      box-shadow: none;
      border-width: 1px;
    }
    .training-viewer-hand {
      width: 100%;
      min-height: 48px;
      background: #f4e0ba;
      border: 1px solid var(--border);
      border-radius: 6px;
      padding: 4px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      justify-content: center;
    }
    .training-viewer-hand .hand-label {
      margin-bottom: 0;
      border-bottom: none;
    }
    .training-viewer-hand .hand-piece {
      min-width: 52px;
      cursor: default;
    }
    .training-hand-empty {
      font-size: 12px;
      color: #7a6644;
    }
    #training-viewer-history {
      width: 100%;
      margin-top: 8px;
      border-top: 1px solid rgba(0,0,0,0.1);
      padding-top: 6px;
    }
    .training-viewer-history-title {
      font-size: 13px;
      font-weight: bold;
      margin-bottom: 4px;
      color: #5e3a12;
    }
    #training-viewer-history-list {
      max-height: 150px;
      overflow-y: auto;
      margin: 0;
      padding-left: 20px;
      font-size: 13px;
    }
    #training-viewer-history-list li {
      line-height: 1.4;
    }
    .training-history-empty {
      font-size: 12px;
      color: #7a6644;
    }
  </style>
</head>
<body>
  <h1>ごろごろ将棋 (5x6)</h1>
  <div id="main-layout">
    <div id="record-panel">
      <div class="panel-title">棋譜</div>
      <div id="history-wrapper">
        <ol id="history-list"></ol>
      </div>
      <div id="history-empty">まだ指し手はありません</div>
      <div class="history-controls">
        <button id="history-start">初期</button>
        <button id="history-prev">◀戻る</button>
        <button id="history-next">進む▶</button>
        <button id="history-latest">最新</button>
      </div>
      <div id="review-status"></div>
    </div>
    <div id="game-container">
      <div id="gote-hand" class="hand">
        <div class="hand-label">後手 (Top)</div>
      </div>
      <div id="board"></div>
      <div id="sente-hand" class="hand">
        <div class="hand-label">先手 (Bottom)</div>
      </div>
    </div>
  </div>

  <div id="status">読み込み中...</div>
  <div id="message"></div>
  <div class="controls">
    <label>先手
      <select id="engine-bottom" data-player="bottom" data-engine-select>
        <option value="human" selected>人間</option>
        <option value="random">ランダム</option>
        <option value="alpha-beta">αβ探索</option>
        <option value="alpha-beta-mobility">αβ探索(機動性)</option>
        <option value="mcts">MCTS</option>
      </select>
    </label>
    <label>後手
      <select id="engine-top" data-player="top" data-engine-select>
        <option value="human">人間</option>
        <option value="random" selected>ランダム</option>
        <option value="alpha-beta">αβ探索</option>
        <option value="alpha-beta-mobility">αβ探索(機動性)</option>
        <option value="mcts">MCTS</option>
      </select>
    </label>
    <button id="auto-btn">AI対局開始</button>
    <button id="reset-btn">最初からやり直す</button>
    <button id="refresh-btn">再読込</button>
  </div>

  <section id="training-panel">
    <h2>エンジン訓練モード</h2>
    <div class="training-form">
      <label>試合数
        <input id="training-games" type="number" min="1" value="20" />
      </label>
      <label>同時進行数
        <input id="training-parallel" type="number" min="1" value="2" />
      </label>
      <label>先手エンジン
        <select id="training-bottom">
          <option value="random">ランダム</option>
          <option value="alpha-beta" selected>αβ探索</option>
          <option value="alpha-beta-mobility">αβ探索(機動性)</option>
          <option value="mcts">MCTS</option>
        </select>
      </label>
      <label>後手エンジン
        <select id="training-top">
          <option value="random" selected>ランダム</option>
          <option value="alpha-beta">αβ探索</option>
          <option value="alpha-beta-mobility">αβ探索(機動性)</option>
          <option value="mcts">MCTS</option>
        </select>
      </label>
      <label>1手ごとの待機(ms)
        <input id="training-interval" type="number" min="0" value="0" />
      </label>
      <label>最大手数
        <input id="training-max-moves" type="number" min="20" value="300" />
      </label>
    </div>
    <div class="training-actions">
      <button id="training-start-btn">訓練開始</button>
      <button id="training-stop-btn" disabled>停止</button>
      <span class="training-config-note" id="training-config-note"></span>
    </div>
    <div id="training-summary"></div>
    <div id="training-message"></div>
    <div id="training-games-list"></div>
    <div id="training-viewer">
      <div class="training-viewer-header">
        <span id="training-viewer-title">訓練試合ビューア</span>
        <button id="training-viewer-close" type="button">表示クリア</button>
      </div>
      <div id="training-viewer-status" class="training-config-note"></div>
      <div id="training-viewer-body">
        <div id="training-viewer-meta"></div>
        <div class="training-viewer-board-wrapper">
          <div id="training-viewer-top-hand" class="training-viewer-hand"></div>
          <div id="training-viewer-board"></div>
          <div id="training-viewer-bottom-hand" class="training-viewer-hand"></div>
        </div>
        <div id="training-viewer-history"></div>
      </div>
    </div>
  </section>

  <script>
    const ROWS = 6;
    const COLS = 5;
    const OWNER_BOTTOM = "bottom";
    const OWNER_TOP = "top";
    const AUTO_POLL_MS = 1200;
    const AUTO_INTERVAL_MS = 1500;
    const TRAINING_POLL_MS = 1500;

    let state = null;
    let selected = null; // {type: 'board'|'hand', x,y, kind}
    let validMoves = [];
    let movesForKey = "";
    let autoPollHandle = null;
    let reviewIndex = 0;
    let followLatest = true;
    let trainingState = null;
    let trainingPollHandle = null;
    let trainingViewerGameId = null;

    const kindToText = {
      K: "王",
      G: "金",
      S: "銀",
      P: "歩",
      "": "",
      "?": "?"
    };

    window.addEventListener("load", () => {
      document.getElementById("reset-btn").onclick = resetGame;
      document.getElementById("refresh-btn").onclick = loadState;
      document.getElementById("auto-btn").onclick = toggleAutoPlay;
      document.getElementById("history-start").onclick = () => setReviewIndex(0);
      document.getElementById("history-prev").onclick = () => shiftReview(-1);
      document.getElementById("history-next").onclick = () => shiftReview(1);
      document.getElementById("history-latest").onclick = () => jumpToLatest();
      document.querySelectorAll("[data-engine-select]").forEach((select) => {
        select.onchange = onEngineChange;
      });
      initTrainingPanel();
      loadState();
    });

    function initTrainingPanel() {
      const startBtn = document.getElementById("training-start-btn");
      const stopBtn = document.getElementById("training-stop-btn");
      const closeBtn = document.getElementById("training-viewer-close");
      if (startBtn) startBtn.onclick = startTraining;
      if (stopBtn) stopBtn.onclick = stopTraining;
      if (closeBtn) closeBtn.onclick = () => clearTrainingViewer();
      setTrainingViewerPlaceholder("進行中の試合をクリックすると盤面を表示します。");
      fetchTrainingState();
    }

    async function fetchTrainingState() {
      try {
        const data = await fetchJSON("/api/training");
        trainingState = data;
        renderTrainingPanel();
        setTrainingMessage("");
        syncTrainingPolling(!!data?.running);
      } catch (err) {
        setTrainingMessage(err.message || String(err));
      }
    }

    async function startTraining() {
      const games = parseInt(document.getElementById("training-games")?.value || "0", 10);
      const parallel = parseInt(document.getElementById("training-parallel")?.value || "0", 10);
      const bottomEngine = document.getElementById("training-bottom")?.value || "";
      const topEngine = document.getElementById("training-top")?.value || "";
      const interval = parseInt(document.getElementById("training-interval")?.value || "0", 10);
      const maxMoves = parseInt(document.getElementById("training-max-moves")?.value || "0", 10);
      if (!games || games < 1) {
        setTrainingMessage("試合数を1以上にしてください。");
        return;
      }
      if (!parallel || parallel < 1) {
        setTrainingMessage("同時進行数を1以上にしてください。");
        return;
      }
      if (!bottomEngine || bottomEngine === "human" || !topEngine || topEngine === "human") {
        setTrainingMessage("両方の手番にAIエンジンを設定してください。");
        return;
      }
      const payload = {
        action: "start",
        games,
        parallel,
        engine_bottom: bottomEngine,
        engine_top: topEngine,
        interval_ms: Math.max(0, interval),
        max_moves: Math.max(0, maxMoves)
      };
      try {
        const data = await fetchJSON("/api/training", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload)
        });
        trainingState = data;
        renderTrainingPanel();
        setTrainingMessage("訓練を開始しました。");
        syncTrainingPolling(true);
      } catch (err) {
        setTrainingMessage(err.message || String(err));
      }
    }

    async function stopTraining() {
      try {
        const data = await fetchJSON("/api/training", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ action: "stop" })
        });
        trainingState = data;
        renderTrainingPanel();
        setTrainingMessage("訓練を停止しました。");
        syncTrainingPolling(false);
      } catch (err) {
        setTrainingMessage(err.message || String(err));
      }
    }

    function renderTrainingPanel() {
      const summaryEl = document.getElementById("training-summary");
      if (!summaryEl) return;
      const running = !!trainingState?.running;
      const summary = trainingState?.summary || {};
      const startBtn = document.getElementById("training-start-btn");
      const stopBtn = document.getElementById("training-stop-btn");
      const noteEl = document.getElementById("training-config-note");
      if (startBtn) startBtn.disabled = running;
      if (stopBtn) stopBtn.disabled = !running;
      if (noteEl) {
        if (trainingState?.config?.parallel) {
          const cfg = trainingState.config;
          noteEl.textContent = `並列 ${cfg.parallel}局 / 最大手数 ${cfg.maxMoves || 0}`;
        } else {
          noteEl.textContent = "";
        }
      }
      if (summary.total) {
        summaryEl.textContent = `進捗 ${summary.completed || 0} / ${summary.total} ｜ 先手勝ち ${summary.bottomWins || 0} ｜ 後手勝ち ${summary.topWins || 0} ｜ 引き分け ${summary.draws || 0}`;
      } else {
        summaryEl.textContent = "訓練は未開始です。";
      }
      if (summary.aborted && !running) {
        summaryEl.textContent += "（中断済み）";
      }
      renderTrainingGames();
      ensureTrainingViewerTargetAvailable();
      refreshTrainingViewerIfNeeded();
    }

    function renderTrainingGames() {
      const listEl = document.getElementById("training-games-list");
      if (!listEl) return;
      listEl.innerHTML = "";
      const games = trainingState?.games || [];
      if (games.length === 0) {
        const empty = document.createElement("div");
        empty.textContent = "進行中の試合はありません。";
        empty.style.opacity = "0.7";
        listEl.appendChild(empty);
        return;
      }
      for (const game of games) {
        const row = document.createElement("div");
        row.className = `training-game-row ${game.state || ""}`.trim();
        if (trainingViewerGameId === game.id) {
          row.classList.add("active");
        }
        const idEl = document.createElement("span");
        idEl.className = "training-game-id";
        idEl.textContent = `#${game.id}`;
        const textEl = document.createElement("span");
        textEl.textContent = formatTrainingGameText(game);
        row.appendChild(idEl);
        row.appendChild(textEl);
        row.tabIndex = 0;
        row.title = "クリックで盤面を表示";
        row.onclick = () => viewTrainingGame(game.id);
        row.onkeydown = (e) => {
          if (e.key === "Enter" || e.key === " ") {
            e.preventDefault();
            viewTrainingGame(game.id);
          }
        };
        listEl.appendChild(row);
      }
    }

    function ensureTrainingViewerTargetAvailable() {
      if (!trainingViewerGameId) return;
      const games = trainingState?.games || [];
      const found = games.some((g) => g.id === trainingViewerGameId);
      if (!found) {
        clearTrainingViewer("表示中の試合は一覧から外れました。");
      }
    }

    function refreshTrainingViewerIfNeeded() {
      if (!trainingViewerGameId) return;
      requestTrainingGameDetail(trainingViewerGameId, { silent: true });
    }

    function viewTrainingGame(gameId) {
      if (!gameId) return;
      trainingViewerGameId = gameId;
      renderTrainingGames();
      requestTrainingGameDetail(gameId, { silent: false });
    }

    async function requestTrainingGameDetail(gameId, { silent } = {}) {
      if (!gameId) return;
      if (!silent) {
        setTrainingViewerPlaceholder("盤面を取得しています...");
      } else {
        setTrainingViewerStatus("更新中...");
      }
      try {
        const detail = await fetchJSON(`/api/training/game?id=${encodeURIComponent(gameId)}`);
        if (trainingViewerGameId !== gameId) return;
        setTrainingViewerStatus("");
        renderTrainingViewer(detail);
      } catch (err) {
        if (trainingViewerGameId !== gameId) return;
        const msg = err.message || String(err);
        if (silent) {
          setTrainingViewerStatus(msg);
        } else {
          setTrainingViewerPlaceholder(msg);
        }
      }
    }

    function clearTrainingViewer(message) {
      trainingViewerGameId = null;
      setTrainingViewerPlaceholder(message || "進行中の試合をクリックすると盤面を表示します。");
      renderTrainingGames();
    }

    function setTrainingViewerPlaceholder(message) {
      const body = document.getElementById("training-viewer-body");
      if (body) {
        body.style.display = "none";
      }
      const titleEl = document.getElementById("training-viewer-title");
      if (titleEl) {
        titleEl.textContent = "訓練試合ビューア";
      }
      setTrainingViewerStatus(message);
    }

    function setTrainingViewerStatus(message) {
      const statusEl = document.getElementById("training-viewer-status");
      if (statusEl) {
        statusEl.textContent = message || "";
      }
    }

    function renderTrainingViewer(detail) {
      const body = document.getElementById("training-viewer-body");
      if (!body) return;
      body.style.display = "block";
      const titleEl = document.getElementById("training-viewer-title");
      if (titleEl) {
        titleEl.textContent = detail?.game ? `試合 #${detail.game.id}` : "訓練試合ビューア";
      }
      const metaEl = document.getElementById("training-viewer-meta");
      if (metaEl) {
        metaEl.textContent = formatTrainingViewerMeta(detail?.game);
      }
      renderTrainingViewerBoard(detail?.snapshot);
      renderTrainingViewerHand("training-viewer-top-hand", "後手", detail?.snapshot?.hands?.top, OWNER_TOP);
      renderTrainingViewerHand("training-viewer-bottom-hand", "先手", detail?.snapshot?.hands?.bottom, OWNER_BOTTOM);
      renderTrainingViewerHistory(detail?.history || []);
    }

    function formatTrainingViewerMeta(game) {
      if (!game) return "";
      const stateMap = { running: "進行中", completed: "完了", error: "エラー", aborted: "中断" };
      const parts = [`状態: ${stateMap[game.state] || game.state || "不明"}`, `手数: ${game.moves || 0}`];
      if (game.lastMove) {
        parts.push(`最終手: ${game.lastMove}`);
      }
      if (game.state === "running" && game.turn) {
        parts.push(`手番: ${labelForOwner(game.turn)}`);
      }
      if (game.result === "win" && game.winner) {
        parts.push(`勝者: ${labelForOwner(game.winner)}`);
      } else if (game.result === "draw") {
        parts.push("結果: 引き分け");
      } else if (game.result === "error" && game.error) {
        parts.push(`エラー: ${game.error}`);
      } else if (game.result === "aborted") {
        parts.push("結果: 中断");
      }
      return parts.join(" ｜ ");
    }

    function renderTrainingViewerBoard(snapshot) {
      const boardEl = document.getElementById("training-viewer-board");
      if (!boardEl) return;
      boardEl.innerHTML = "";
      for (let displayRow = ROWS - 1; displayRow >= 0; displayRow--) {
        for (let x = 0; x < COLS; x++) {
          const cell = document.createElement("div");
          cell.className = "cell";
          const row = snapshot?.board?.[displayRow] || [];
          const piece = row[x];
          if (piece?.present) {
            const pieceEl = createPieceElement(piece);
            pieceEl.draggable = false;
            cell.appendChild(pieceEl);
          }
          boardEl.appendChild(cell);
        }
      }
    }

    function renderTrainingViewerHand(elementId, label, hand, owner) {
      const handEl = document.getElementById(elementId);
      if (!handEl) return;
      handEl.innerHTML = `<div class="hand-label">${label}</div>`;
      const entries = hand ? Object.entries(hand) : [];
      if (entries.length === 0) {
        const empty = document.createElement("div");
        empty.className = "training-hand-empty";
        empty.textContent = "なし";
        handEl.appendChild(empty);
        return;
      }
      const order = ["K", "G", "S", "P"];
      entries.sort((a, b) => {
        const ai = order.indexOf(a[0]);
        const bi = order.indexOf(b[0]);
        const av = ai === -1 ? 99 : ai;
        const bv = bi === -1 ? 99 : bi;
        if (av !== bv) return av - bv;
        return a[0].localeCompare(b[0]);
      });
      entries.forEach(([kind, count]) => {
        const pieceEl = createPieceElement({ kind, owner, promoted: false });
        pieceEl.classList.add("hand-piece");
        pieceEl.draggable = false;
        const countEl = document.createElement("span");
        countEl.className = "count";
        countEl.textContent = `x${count}`;
        pieceEl.appendChild(countEl);
        handEl.appendChild(pieceEl);
      });
    }

    function renderTrainingViewerHistory(entries) {
      const container = document.getElementById("training-viewer-history");
      if (!container) return;
      container.innerHTML = "";
      const title = document.createElement("div");
      title.className = "training-viewer-history-title";
      title.textContent = "棋譜";
      container.appendChild(title);
      if (!entries || entries.length === 0) {
        const empty = document.createElement("div");
        empty.className = "training-history-empty";
        empty.textContent = "まだ着手はありません。";
        container.appendChild(empty);
        return;
      }
      const list = document.createElement("ol");
      list.id = "training-viewer-history-list";
      entries.forEach((entry) => {
        const item = document.createElement("li");
        item.textContent = `${labelForOwner(entry.player)} ${entry.move}`;
        list.appendChild(item);
      });
      container.appendChild(list);
      list.scrollTop = list.scrollHeight;
    }

    function formatTrainingGameText(game) {
      const stateMap = { running: "進行中", completed: "完了", error: "エラー", aborted: "中断" };
      const stateLabel = stateMap[game.state] || (game.state || "状態不明");
      const moves = typeof game.moves === "number" ? game.moves : 0;
      const parts = [stateLabel, `${moves}手`];
      if (game.state === "running" && game.turn) {
        parts.push(`手番: ${labelForOwner(game.turn)}`);
      }
      if (game.lastMove) {
        parts.push(`最終手: ${game.lastMove}`);
      }
      if (game.result === "win" && game.winner) {
        parts.push(`勝者: ${labelForOwner(game.winner)}`);
      } else if (game.result === "draw") {
        parts.push("引き分け");
      } else if (game.result === "error" && game.error) {
        parts.push(game.error);
      } else if (game.result === "aborted") {
        parts.push("中断");
      }
      return parts.join(" ｜ ");
    }

    function setTrainingMessage(msg) {
      const el = document.getElementById("training-message");
      if (el) {
        el.textContent = msg || "";
      }
    }

    function syncTrainingPolling(running) {
      if (running) {
        if (trainingPollHandle) return;
        trainingPollHandle = setInterval(fetchTrainingState, TRAINING_POLL_MS);
      } else if (trainingPollHandle) {
        clearInterval(trainingPollHandle);
        trainingPollHandle = null;
      }
    }

    function labelForOwner(owner) {
      if (owner === OWNER_BOTTOM) return "先手";
      if (owner === OWNER_TOP) return "後手";
      return owner || "";
    }

    async function loadState() {
      try {
        await fetchAndRenderState();
        setMessage("");
      } catch (err) {
        setMessage(err.message || String(err));
      }
    }

    async function fetchAndRenderState() {
      const payload = await fetchJSON("/api/state");
      state = payload;
      selected = null;
      validMoves = [];
      movesForKey = "";
      clampReviewIndex();
      render();
    }

    async function resetGame() {
      try {
        const payload = await fetchJSON("/api/reset", { method: "POST" });
        state = payload;
        selected = null;
        validMoves = [];
        movesForKey = "";
        followLatest = true;
        reviewIndex = 0;
        render();
        setMessage("リセットしました。");
      } catch (err) {
        setMessage(err.message || String(err));
      }
    }

    async function onEngineChange(e) {
      const select = e.target;
      const choice = select.value;
      const player = select.dataset.player || OWNER_TOP;
      try {
        await fetchJSON("/api/engine", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ engine: choice, player })
        });
        await fetchAndRenderState();
        setMessage("エンジン設定を更新しました。");
      } catch (err) {
        setMessage(err.message || String(err));
        const engines = state?.engines || {};
        if (player === OWNER_TOP && (engines.top || state?.engine)) {
          select.value = engines.top || state.engine;
        } else if (player === OWNER_BOTTOM && engines.bottom) {
          select.value = engines.bottom;
        }
      }
    }

    function render() {
      if (!state) return;
      clampReviewIndex();
      const view = getActiveView();
      if (!view) return;
      renderHands(view);
      renderBoard(view);
      renderHistory();
      renderReviewStatus();
      updateStatus(view);
      updateEngineSelectors();
      updateAutoControls();
      syncAutoPolling(!!state.autoPlaying);
    }

    function renderHistory() {
      const list = document.getElementById("history-list");
      const emptyEl = document.getElementById("history-empty");
      if (!list || !emptyEl) return;
      list.innerHTML = "";
      const entries = state.history || [];
      if (entries.length === 0) {
        emptyEl.style.display = "block";
        return;
      }
      emptyEl.style.display = "none";
      const highlightIndex = !isLiveView() ? currentReviewIndex() : -1;
      entries.forEach((entry, idx) => {
        const item = document.createElement("li");
        const label = entry.player === OWNER_BOTTOM ? "先手" : "後手";
        item.textContent = `${label} ${entry.move}`;
        if (highlightIndex === idx + 1) {
          item.classList.add("active");
        }
        item.onclick = () => setReviewIndex(idx + 1);
        list.appendChild(item);
      });
      if (isLiveView()) {
        list.scrollTop = list.scrollHeight;
      }
    }

    function renderHands(view) {
      renderHand("gote-hand", OWNER_TOP, view);
      renderHand("sente-hand", OWNER_BOTTOM, view);
    }

    function renderHand(elementId, owner, view) {
      const handEl = document.getElementById(elementId);
      handEl.innerHTML = `<div class="hand-label">${owner === OWNER_BOTTOM ? "先手 (Bottom)" : "後手 (Top)"}</div>`;
      const hand = view?.hands?.[owner] || {};
      const entries = Object.entries(hand);
      if (entries.length === 0) {
        const empty = document.createElement("div");
        empty.textContent = "なし";
        empty.style.opacity = "0.6";
        handEl.appendChild(empty);
        return;
      }
      const interactive = isLiveView() && !state.autoPlaying && state.turn === owner && !state.checkmate;
      entries.forEach(([kind, count]) => {
        const pieceEl = createPieceElement({ kind, owner, promoted: false, present: true });
        pieceEl.classList.add("hand-piece");
        pieceEl.title = `打つ (${count}枚)`;
        const countEl = document.createElement("span");
        countEl.className = "count";
        countEl.textContent = `x${count}`;
        pieceEl.appendChild(countEl);

        if (interactive) {
          pieceEl.draggable = true;
          pieceEl.onclick = async (e) => {
            e.stopPropagation();
            await setSelection({ type: "hand", kind, owner });
          };
          pieceEl.ondragstart = async (e) => {
            await setSelection({ type: "hand", kind, owner });
            e.dataTransfer.setData("text/plain", JSON.stringify({ kind, type: "hand" }));
          };
        } else {
          pieceEl.draggable = false;
        }

        if (interactive && selected && selected.type === "hand" && selected.kind === kind && selected.owner === owner) {
          pieceEl.classList.add("selected-hand");
        }

        handEl.appendChild(pieceEl);
      });
    }

    function renderBoard(view) {
      const boardEl = document.getElementById("board");
      boardEl.innerHTML = "";
      const interactive = isLiveView() && !state.autoPlaying && !state.checkmate;
      for (let displayRow = ROWS - 1; displayRow >= 0; displayRow--) {
        for (let x = 0; x < COLS; x++) {
          const y = displayRow;
          const cell = document.createElement("div");
          cell.className = "cell";
          const coord = coordToString(x, y);

          if (interactive && selected && selected.type === "board" && selected.x === x && selected.y === y) {
            cell.classList.add("selected");
          }

          if (interactive && isValidDestination(coord)) {
            cell.classList.add("valid");
          }

          cell.onclick = async () => {
            if (!interactive) return;
            await onCellClick(x, y);
          };
          cell.ondragover = (e) => {
            if (!interactive) return;
            e.preventDefault();
            e.dataTransfer.dropEffect = "move";
          };
          cell.ondragenter = (e) => {
            if (!interactive) return;
            e.preventDefault();
            cell.classList.add("drag-over");
          };
          cell.ondragleave = () => cell.classList.remove("drag-over");
          cell.ondrop = async (e) => {
            if (!interactive) return;
            e.preventDefault();
            cell.classList.remove("drag-over");
            const raw = e.dataTransfer.getData("text/plain");
            if (raw) {
              try {
                const data = JSON.parse(raw);
                if (data.type === "board") {
                  await setSelection({ type: "board", x: data.x, y: data.y, owner: data.owner });
                } else if (data.type === "hand") {
                  await setSelection({ type: "hand", kind: data.kind, owner: state.turn });
                }
              } catch (_) {}
            }
            await attemptMove(x, y);
          };

          const row = view.board && view.board[y] ? view.board[y] : null;
          const piece = row ? row[x] : null;
          if (piece && piece.present) {
            const pieceEl = createPieceElement(piece);
            if (interactive && state.turn === piece.owner) {
              pieceEl.draggable = true;
              pieceEl.ondragstart = async (e) => {
                await setSelection({ type: "board", x, y, owner: piece.owner });
                e.dataTransfer.setData("text/plain", JSON.stringify({ type: "board", x, y, owner: piece.owner }));
              };
            }
            pieceEl.onclick = async (e) => {
              if (!interactive) return;
              e.stopPropagation();
              if (piece.owner !== state.turn) return;
              await setSelection({ type: "board", x, y, owner: piece.owner });
            };
            cell.appendChild(pieceEl);
          }

          boardEl.appendChild(cell);
        }
      }
    }

    async function onCellClick(x, y) {
      if (!state || !isLiveView() || state.autoPlaying) return;
      const piece = state.board[y][x];
      if (!selected) {
        if (piece?.present && piece.owner === state.turn) {
          await setSelection({ type: "board", x, y, owner: piece.owner });
        }
        return;
      }
      await attemptMove(x, y);
    }

    async function attemptMove(x, y) {
      if (!selected) return;
      if (!isLiveView()) {
        setMessage("棋譜再生中は操作できません。最新局面を表示してください。");
        selected = null;
        validMoves = [];
        movesForKey = "";
        render();
        return;
      }
      if (state?.autoPlaying) {
        setMessage("AI対局中は指せません。");
        selected = null;
        validMoves = [];
        movesForKey = "";
        render();
        return;
      }
      await ensureMovesLoaded();

      const coord = coordToString(x, y);
      const options = validMoves.filter((m) => m.to === coord);
      if (options.length === 0) {
        selected = null;
        validMoves = [];
        movesForKey = "";
        render();
        return;
      }

      let promote = options[0].promote;
      const hasPromote = options.some((m) => m.promote);
      const hasNoPromote = options.some((m) => !m.promote);
      if (hasPromote && hasNoPromote) {
        promote = window.confirm("成りますか？");
      }

      const payload = { to: coord, promote: !!promote };
      if (selected.type === "board") {
        payload.from = coordToString(selected.x, selected.y);
      } else if (selected.type === "hand") {
        payload.drop = selected.kind;
      }

      try {
        const result = await fetchJSON("/api/move", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!result.success) {
          setMessage(result.error || "移動できません。");
          state = result.state || state;
        } else {
          state = result.state;
          followLatest = true;
          setMessage(result.message || "");
          if (result.winner) {
            setMessage(`勝者: ${result.winner}`);
          }
        }
      } catch (err) {
        setMessage(err.message || String(err));
      }

      selected = null;
      validMoves = [];
      movesForKey = "";
      clampReviewIndex();
      render();
    }

    async function setSelection(sel) {
      if (!state || !isLiveView() || state.autoPlaying || state.turn !== sel.owner) {
        selected = null;
        validMoves = [];
        movesForKey = "";
        if (state?.autoPlaying) {
          setMessage("AI対局中は操作できません。");
        } else if (!isLiveView()) {
          setMessage("棋譜再生中は操作できません。最新局面を表示してください。");
        }
        render();
        return;
      }
      selected = sel;
      await ensureMovesLoaded();
      render();
    }

    async function ensureMovesLoaded() {
      if (!selected) return;
      const key = selectionKey(selected);
      if (key === movesForKey && validMoves.length > 0) return;

      let url = "/api/legal?";
      if (selected.type === "board") {
        url += `from=${encodeURIComponent(coordToString(selected.x, selected.y))}`;
      } else {
        url += `drop=${encodeURIComponent(selected.kind)}`;
      }
      try {
        const data = await fetchJSON(url);
        validMoves = data.moves || [];
        movesForKey = key;
      } catch (err) {
        setMessage(err.message || String(err));
        validMoves = [];
        movesForKey = "";
      }
    }

    function isValidDestination(coord) {
      return validMoves.some((m) => m.to === coord);
    }

    function createPieceElement(piece) {
      const pieceEl = document.createElement("div");
      pieceEl.className = "piece";
      if (piece.owner === OWNER_TOP) pieceEl.classList.add("gote");
      if (piece.promoted) pieceEl.classList.add("promoted");
      const baseText = kindToText[piece.kind] || "?";
      pieceEl.textContent = piece.promoted ? (piece.kind === "S" ? "全" : piece.kind === "P" ? "と" : baseText) : baseText;
      return pieceEl;
    }

    function updateStatus(view) {
      const statusEl = document.getElementById("status");
      if (!state || !view) {
        statusEl.textContent = "未接続";
        return;
      }
      if (view.checkmate && view.winner) {
        statusEl.textContent = `勝者: ${view.winner}`;
        return;
      }
      const turnText = view.turn === OWNER_BOTTOM ? "先手" : "後手";
      if (!isLiveView()) {
        statusEl.textContent = `棋譜再生中: ${turnText}の手番`;
        if (view.check) {
          statusEl.textContent += "（王手）";
        }
        return;
      }
      if (state.autoPlaying) {
        statusEl.textContent = `AI対局中 (${turnText}の手番)`;
        if (view.check) {
          statusEl.textContent += "（王手）";
        }
        return;
      }
      statusEl.textContent = `${turnText}の手番`;
      if (view.check) {
        statusEl.textContent += "（王手）";
      }
    }

    function setMessage(msg) {
      const el = document.getElementById("message");
      el.textContent = msg || "";
    }

    function updateEngineSelectors() {
      const mapping = state?.engines || {};
      const topSelect = document.getElementById("engine-top");
      const bottomSelect = document.getElementById("engine-bottom");
      if (topSelect) {
        topSelect.value = mapping.top || state?.engine || "random";
      }
      if (bottomSelect) {
        bottomSelect.value = mapping.bottom || "human";
      }
    }

    function updateAutoControls() {
      const btn = document.getElementById("auto-btn");
      if (!btn) return;
      const running = !!state?.autoPlaying;
      btn.textContent = running ? "AI対局停止" : "AI対局開始";
      if (running) {
        btn.disabled = false;
        return;
      }
      const engines = state?.engines || {};
      const ready = engines.bottom && engines.top && engines.bottom !== "human" && engines.top !== "human";
      btn.disabled = !ready;
    }

    async function toggleAutoPlay() {
      if (!state) return;
      const running = !state.autoPlaying;
      try {
        await fetchJSON("/api/auto", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ running, interval_ms: AUTO_INTERVAL_MS })
        });
        await fetchAndRenderState();
        setMessage(running ? "AI対局を開始しました。" : "AI対局を停止しました。");
      } catch (err) {
        setMessage(err.message || String(err));
      }
    }

    function syncAutoPolling(running) {
      if (running) {
        if (autoPollHandle) return;
        autoPollHandle = setInterval(fetchAndRenderState, AUTO_POLL_MS);
      } else if (autoPollHandle) {
        clearInterval(autoPollHandle);
        autoPollHandle = null;
      }
    }

    function timelineLength() {
      if (!state) return 0;
      const historyCount = state.history ? state.history.length : 0;
      return historyCount + 1;
    }

    function clampReviewIndex() {
      if (!state) return;
      const max = timelineLength() - 1;
      if (max < 0) {
        reviewIndex = 0;
        return;
      }
      if (reviewIndex > max) reviewIndex = max;
      if (reviewIndex < 0) reviewIndex = 0;
    }

    function currentReviewIndex() {
      if (!state) return 0;
      const max = timelineLength() - 1;
      if (followLatest) {
        return max;
      }
      const clamped = Math.max(0, Math.min(reviewIndex, max));
      reviewIndex = clamped;
      return clamped;
    }

    function getSnapshotAt(index) {
      if (!state) return null;
      if (index === 0) {
        return state.initial || null;
      }
      const history = state.history || [];
      const entry = history[index - 1];
      return entry ? entry.snapshot : null;
    }

    function getActiveView() {
      if (!state) return null;
      const index = currentReviewIndex();
      if (index === timelineLength() - 1) {
        return state;
      }
      return getSnapshotAt(index) || state;
    }

    function isLiveView() {
      if (!state) return false;
      return followLatest && currentReviewIndex() === timelineLength() - 1;
    }

    function setReviewIndex(index) {
      if (!state) return;
      followLatest = false;
      const max = timelineLength() - 1;
      reviewIndex = Math.max(0, Math.min(index, max));
      selected = null;
      validMoves = [];
      movesForKey = "";
      render();
    }

    function shiftReview(delta) {
      if (!state) return;
      const target = currentReviewIndex() + delta;
      setReviewIndex(target);
    }

    function jumpToLatest() {
      if (!state) return;
      followLatest = true;
      const max = timelineLength() - 1;
      reviewIndex = max < 0 ? 0 : max;
      selected = null;
      validMoves = [];
      movesForKey = "";
      render();
    }

    function renderReviewStatus() {
      const el = document.getElementById("review-status");
      if (!el || !state) return;
      const total = timelineLength();
      if (total <= 1) {
        el.textContent = "";
        el.classList.remove("active");
        return;
      }
      if (isLiveView()) {
        el.textContent = "最新局面を表示中";
        el.classList.remove("active");
        return;
      }
      const index = currentReviewIndex();
      let label = "初期局面";
      if (index > 0) {
        const entry = state.history?.[index - 1];
        if (entry) {
          const turnLabel = entry.player === OWNER_BOTTOM ? "先手" : "後手";
          label = `${index}手目 (${turnLabel} ${entry.move})`;
        }
      }
      el.textContent = `棋譜再生: ${label}`;
      el.classList.add("active");
    }

    function coordToString(x, y) {
      return `${String.fromCharCode("a".charCodeAt(0) + x)}${y + 1}`;
    }

    function selectionKey(sel) {
      if (!sel) return "";
      if (sel.type === "hand") return `hand-${sel.owner}-${sel.kind}`;
      return `board-${sel.owner}-${sel.x}-${sel.y}`;
    }

    async function fetchJSON(url, options = {}) {
      const res = await fetch(url, options);
      const text = await res.text();
      let data = null;
      if (text) {
        try {
          data = JSON.parse(text);
        } catch (_) {
          data = null;
        }
      }
      if (!res.ok) {
        const msg = (data && (data.error || data.message)) || text || res.statusText;
        const err = new Error(msg);
        err.data = data;
        throw err;
      }
      return data;
    }
  </script>
</body>
</html>

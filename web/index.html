<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ごろごろ将棋 (5x6)</title>
  <style>
    :root {
      --wood: #f2d696;
      --border: #5c4424;
      --highlight: #87cefa;
      --drop: #ff9800;
      --text: #2d1b0e;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      padding: 20px;
      font-family: "Hiragino Sans", "Yu Gothic", sans-serif;
      background: radial-gradient(circle at 20% 20%, #fffaf0, #f0e6d0);
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      user-select: none;
      -webkit-user-drag: none;
    }
    h1 {
      margin: 0;
      font-size: 24px;
      letter-spacing: 0.05em;
    }
    #main-layout {
      display: flex;
      gap: 20px;
      align-items: flex-start;
      justify-content: center;
      flex-wrap: wrap;
      width: min(100%, 900px);
    }
    #record-panel {
      width: 200px;
      background: #f7e6c1;
      border: 2px solid var(--border);
      border-radius: 8px;
      padding: 10px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.15);
    }
    .panel-title {
      font-size: 14px;
      font-weight: bold;
      text-align: center;
      margin-bottom: 6px;
      color: #5e3a12;
    }
    #history-wrapper {
      max-height: 420px;
      overflow-y: auto;
    }
    #history-list {
      list-style: decimal;
      list-style-position: inside;
      margin: 0;
      padding-left: 18px;
      font-size: 14px;
    }
    #history-list li {
      padding: 4px;
      border-radius: 4px;
      background: rgba(255, 255, 255, 0.6);
    }
    #history-list li.active {
      background: #ffe2b6;
      font-weight: bold;
      border: 1px solid rgba(0,0,0,0.15);
    }
    #history-list li + li {
      margin-top: 4px;
    }
    #history-empty {
      text-align: center;
      font-size: 13px;
      color: #7a6644;
      padding: 8px 0;
    }
    .history-controls {
      margin-top: 8px;
      display: grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap: 6px;
    }
    .history-controls button {
      font-size: 12px;
      padding: 6px 0;
    }
    #review-status {
      margin-top: 4px;
      font-size: 12px;
      text-align: center;
      min-height: 18px;
      color: #6b4a1c;
    }
    #review-status.active {
      font-weight: bold;
      color: #c0392b;
    }
    #game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }
    .hand {
      width: 320px;
      min-height: 60px;
      background: #e8d0a9;
      border: 2px solid var(--border);
      display: flex;
      flex-wrap: wrap;
      padding: 6px;
      gap: 6px;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
    }
    .hand-label {
      width: 100%;
      font-size: 12px;
      text-align: center;
      color: #5e3a12;
      border-bottom: 1px solid var(--border);
      margin-bottom: 2px;
      padding-bottom: 2px;
      pointer-events: none;
    }
    #board {
      display: grid;
      grid-template-columns: repeat(5, 64px);
      grid-template-rows: repeat(6, 64px);
      border: 2px solid #333;
      background: var(--wood);
      box-shadow: 0 4px 12px rgba(0,0,0,0.2);
    }
    .cell {
      width: 64px;
      height: 64px;
      border: 1px solid #555;
      display: flex;
      justify-content: center;
      align-items: center;
      position: relative;
      transition: background-color 0.15s ease;
    }
    .cell.selected { background: var(--highlight); }
    .cell.valid::after {
      content: "";
      position: absolute;
      width: 14px;
      height: 14px;
      background: rgba(255, 0, 0, 0.45);
      border-radius: 50%;
    }
    .cell.drag-over {
      background: #ffeb3b;
      border-color: var(--drop);
    }
    .piece {
      width: 54px;
      height: 54px;
      background: #ffefc0;
      border: 1px solid #8b5a2b;
      border-bottom: 3px solid #8b5a2b;
      border-radius: 6px 6px 16px 16px;
      display: flex;
      justify-content: center;
      align-items: center;
      font-size: 26px;
      font-weight: bold;
      color: #000;
      box-shadow: 1px 1px 3px rgba(0,0,0,0.3);
      cursor: grab;
      transition: transform 0.1s ease;
    }
    .piece:active { cursor: grabbing; }
    .piece.gote { transform: rotate(180deg); }
    .piece.promoted { color: #d00; }
    .hand-piece { min-width: 60px; justify-content: space-between; padding: 0 8px; cursor: pointer; }
    .hand-piece .count { font-size: 12px; }
    .piece.selected-hand { background: var(--highlight); border-color: #0056b3; }
    #status {
      font-weight: bold;
      font-size: 16px;
    }
    #message {
      min-height: 18px;
      color: #c00;
      font-size: 14px;
    }
    .controls {
      display: flex;
      gap: 8px;
    }
    .controls label {
      display: flex;
      align-items: center;
      gap: 6px;
      font-size: 14px;
    }
    select {
      padding: 6px 10px;
      border: 1px solid var(--border);
      border-radius: 6px;
      background: #fffef6;
      font-size: 14px;
    }
    button {
      padding: 8px 14px;
      font-size: 14px;
      cursor: pointer;
      border: 1px solid var(--border);
      background: #fff;
      border-radius: 6px;
      box-shadow: 0 1px 3px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
  <h1>ごろごろ将棋 (5x6)</h1>
  <div id="main-layout">
    <div id="record-panel">
      <div class="panel-title">棋譜</div>
      <div id="history-wrapper">
        <ol id="history-list"></ol>
      </div>
      <div id="history-empty">まだ指し手はありません</div>
      <div class="history-controls">
        <button id="history-start">初期</button>
        <button id="history-prev">◀戻る</button>
        <button id="history-next">進む▶</button>
        <button id="history-latest">最新</button>
      </div>
      <div id="review-status"></div>
    </div>
    <div id="game-container">
      <div id="gote-hand" class="hand">
        <div class="hand-label">後手 (Top)</div>
      </div>
      <div id="board"></div>
      <div id="sente-hand" class="hand">
        <div class="hand-label">先手 (Bottom)</div>
      </div>
    </div>
  </div>

  <div id="status">読み込み中...</div>
  <div id="message"></div>
  <div class="controls">
    <label>先手
      <select id="engine-bottom" data-player="bottom" data-engine-select>
        <option value="human" selected>人間</option>
        <option value="random">ランダム</option>
        <option value="alpha-beta">αβ探索</option>
      </select>
    </label>
    <label>後手
      <select id="engine-top" data-player="top" data-engine-select>
        <option value="human">人間</option>
        <option value="random" selected>ランダム</option>
        <option value="alpha-beta">αβ探索</option>
      </select>
    </label>
    <button id="auto-btn">AI対局開始</button>
    <button id="reset-btn">最初からやり直す</button>
    <button id="refresh-btn">再読込</button>
  </div>

  <script>
    const ROWS = 6;
    const COLS = 5;
    const OWNER_BOTTOM = "bottom";
    const OWNER_TOP = "top";
    const AUTO_POLL_MS = 1200;
    const AUTO_INTERVAL_MS = 1500;

    let state = null;
    let selected = null; // {type: 'board'|'hand', x,y, kind}
    let validMoves = [];
    let movesForKey = "";
    let autoPollHandle = null;
    let reviewIndex = 0;
    let followLatest = true;

    const kindToText = {
      K: "王",
      G: "金",
      S: "銀",
      P: "歩",
      "": "",
      "?": "?"
    };

    window.addEventListener("load", () => {
      document.getElementById("reset-btn").onclick = resetGame;
      document.getElementById("refresh-btn").onclick = loadState;
      document.getElementById("auto-btn").onclick = toggleAutoPlay;
      document.getElementById("history-start").onclick = () => setReviewIndex(0);
      document.getElementById("history-prev").onclick = () => shiftReview(-1);
      document.getElementById("history-next").onclick = () => shiftReview(1);
      document.getElementById("history-latest").onclick = () => jumpToLatest();
      document.querySelectorAll("[data-engine-select]").forEach((select) => {
        select.onchange = onEngineChange;
      });
      loadState();
    });

    async function loadState() {
      try {
        await fetchAndRenderState();
        setMessage("");
      } catch (err) {
        setMessage(err.message || String(err));
      }
    }

    async function fetchAndRenderState() {
      const payload = await fetchJSON("/api/state");
      state = payload;
      selected = null;
      validMoves = [];
      movesForKey = "";
      clampReviewIndex();
      render();
    }

    async function resetGame() {
      try {
        const payload = await fetchJSON("/api/reset", { method: "POST" });
        state = payload;
        selected = null;
        validMoves = [];
        movesForKey = "";
        followLatest = true;
        reviewIndex = 0;
        render();
        setMessage("リセットしました。");
      } catch (err) {
        setMessage(err.message || String(err));
      }
    }

    async function onEngineChange(e) {
      const select = e.target;
      const choice = select.value;
      const player = select.dataset.player || OWNER_TOP;
      try {
        await fetchJSON("/api/engine", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ engine: choice, player })
        });
        await fetchAndRenderState();
        setMessage("エンジン設定を更新しました。");
      } catch (err) {
        setMessage(err.message || String(err));
        const engines = state?.engines || {};
        if (player === OWNER_TOP && (engines.top || state?.engine)) {
          select.value = engines.top || state.engine;
        } else if (player === OWNER_BOTTOM && engines.bottom) {
          select.value = engines.bottom;
        }
      }
    }

    function render() {
      if (!state) return;
      clampReviewIndex();
      const view = getActiveView();
      if (!view) return;
      renderHands(view);
      renderBoard(view);
      renderHistory();
      renderReviewStatus();
      updateStatus(view);
      updateEngineSelectors();
      updateAutoControls();
      syncAutoPolling(!!state.autoPlaying);
    }

    function renderHistory() {
      const list = document.getElementById("history-list");
      const emptyEl = document.getElementById("history-empty");
      if (!list || !emptyEl) return;
      list.innerHTML = "";
      const entries = state.history || [];
      if (entries.length === 0) {
        emptyEl.style.display = "block";
        return;
      }
      emptyEl.style.display = "none";
      const highlightIndex = !isLiveView() ? currentReviewIndex() : -1;
      entries.forEach((entry, idx) => {
        const item = document.createElement("li");
        const label = entry.player === OWNER_BOTTOM ? "先手" : "後手";
        item.textContent = `${label} ${entry.move}`;
        if (highlightIndex === idx + 1) {
          item.classList.add("active");
        }
        item.onclick = () => setReviewIndex(idx + 1);
        list.appendChild(item);
      });
      if (isLiveView()) {
        list.scrollTop = list.scrollHeight;
      }
    }

    function renderHands(view) {
      renderHand("gote-hand", OWNER_TOP, view);
      renderHand("sente-hand", OWNER_BOTTOM, view);
    }

    function renderHand(elementId, owner, view) {
      const handEl = document.getElementById(elementId);
      handEl.innerHTML = `<div class="hand-label">${owner === OWNER_BOTTOM ? "先手 (Bottom)" : "後手 (Top)"}</div>`;
      const hand = view?.hands?.[owner] || {};
      const entries = Object.entries(hand);
      if (entries.length === 0) {
        const empty = document.createElement("div");
        empty.textContent = "なし";
        empty.style.opacity = "0.6";
        handEl.appendChild(empty);
        return;
      }
      const interactive = isLiveView() && !state.autoPlaying && state.turn === owner && !state.checkmate;
      entries.forEach(([kind, count]) => {
        const pieceEl = createPieceElement({ kind, owner, promoted: false, present: true });
        pieceEl.classList.add("hand-piece");
        pieceEl.title = `打つ (${count}枚)`;
        const countEl = document.createElement("span");
        countEl.className = "count";
        countEl.textContent = `x${count}`;
        pieceEl.appendChild(countEl);

        if (interactive) {
          pieceEl.draggable = true;
          pieceEl.onclick = async (e) => {
            e.stopPropagation();
            await setSelection({ type: "hand", kind, owner });
          };
          pieceEl.ondragstart = async (e) => {
            await setSelection({ type: "hand", kind, owner });
            e.dataTransfer.setData("text/plain", JSON.stringify({ kind, type: "hand" }));
          };
        } else {
          pieceEl.draggable = false;
        }

        if (interactive && selected && selected.type === "hand" && selected.kind === kind && selected.owner === owner) {
          pieceEl.classList.add("selected-hand");
        }

        handEl.appendChild(pieceEl);
      });
    }

    function renderBoard(view) {
      const boardEl = document.getElementById("board");
      boardEl.innerHTML = "";
      const interactive = isLiveView() && !state.autoPlaying && !state.checkmate;
      for (let displayRow = ROWS - 1; displayRow >= 0; displayRow--) {
        for (let x = 0; x < COLS; x++) {
          const y = displayRow;
          const cell = document.createElement("div");
          cell.className = "cell";
          const coord = coordToString(x, y);

          if (interactive && selected && selected.type === "board" && selected.x === x && selected.y === y) {
            cell.classList.add("selected");
          }

          if (interactive && isValidDestination(coord)) {
            cell.classList.add("valid");
          }

          cell.onclick = async () => {
            if (!interactive) return;
            await onCellClick(x, y);
          };
          cell.ondragover = (e) => {
            if (!interactive) return;
            e.preventDefault();
            e.dataTransfer.dropEffect = "move";
          };
          cell.ondragenter = (e) => {
            if (!interactive) return;
            e.preventDefault();
            cell.classList.add("drag-over");
          };
          cell.ondragleave = () => cell.classList.remove("drag-over");
          cell.ondrop = async (e) => {
            if (!interactive) return;
            e.preventDefault();
            cell.classList.remove("drag-over");
            const raw = e.dataTransfer.getData("text/plain");
            if (raw) {
              try {
                const data = JSON.parse(raw);
                if (data.type === "board") {
                  await setSelection({ type: "board", x: data.x, y: data.y, owner: data.owner });
                } else if (data.type === "hand") {
                  await setSelection({ type: "hand", kind: data.kind, owner: state.turn });
                }
              } catch (_) {}
            }
            await attemptMove(x, y);
          };

          const row = view.board && view.board[y] ? view.board[y] : null;
          const piece = row ? row[x] : null;
          if (piece && piece.present) {
            const pieceEl = createPieceElement(piece);
            if (interactive && state.turn === piece.owner) {
              pieceEl.draggable = true;
              pieceEl.ondragstart = async (e) => {
                await setSelection({ type: "board", x, y, owner: piece.owner });
                e.dataTransfer.setData("text/plain", JSON.stringify({ type: "board", x, y, owner: piece.owner }));
              };
            }
            pieceEl.onclick = async (e) => {
              if (!interactive) return;
              e.stopPropagation();
              if (piece.owner !== state.turn) return;
              await setSelection({ type: "board", x, y, owner: piece.owner });
            };
            cell.appendChild(pieceEl);
          }

          boardEl.appendChild(cell);
        }
      }
    }

    async function onCellClick(x, y) {
      if (!state || !isLiveView() || state.autoPlaying) return;
      const piece = state.board[y][x];
      if (!selected) {
        if (piece?.present && piece.owner === state.turn) {
          await setSelection({ type: "board", x, y, owner: piece.owner });
        }
        return;
      }
      await attemptMove(x, y);
    }

    async function attemptMove(x, y) {
      if (!selected) return;
      if (!isLiveView()) {
        setMessage("棋譜再生中は操作できません。最新局面を表示してください。");
        selected = null;
        validMoves = [];
        movesForKey = "";
        render();
        return;
      }
      if (state?.autoPlaying) {
        setMessage("AI対局中は指せません。");
        selected = null;
        validMoves = [];
        movesForKey = "";
        render();
        return;
      }
      await ensureMovesLoaded();

      const coord = coordToString(x, y);
      const options = validMoves.filter((m) => m.to === coord);
      if (options.length === 0) {
        selected = null;
        validMoves = [];
        movesForKey = "";
        render();
        return;
      }

      let promote = options[0].promote;
      const hasPromote = options.some((m) => m.promote);
      const hasNoPromote = options.some((m) => !m.promote);
      if (hasPromote && hasNoPromote) {
        promote = window.confirm("成りますか？");
      }

      const payload = { to: coord, promote: !!promote };
      if (selected.type === "board") {
        payload.from = coordToString(selected.x, selected.y);
      } else if (selected.type === "hand") {
        payload.drop = selected.kind;
      }

      try {
        const result = await fetchJSON("/api/move", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (!result.success) {
          setMessage(result.error || "移動できません。");
          state = result.state || state;
        } else {
          state = result.state;
          followLatest = true;
          setMessage(result.message || "");
          if (result.winner) {
            setMessage(`勝者: ${result.winner}`);
          }
        }
      } catch (err) {
        setMessage(err.message || String(err));
      }

      selected = null;
      validMoves = [];
      movesForKey = "";
      clampReviewIndex();
      render();
    }

    async function setSelection(sel) {
      if (!state || !isLiveView() || state.autoPlaying || state.turn !== sel.owner) {
        selected = null;
        validMoves = [];
        movesForKey = "";
        if (state?.autoPlaying) {
          setMessage("AI対局中は操作できません。");
        } else if (!isLiveView()) {
          setMessage("棋譜再生中は操作できません。最新局面を表示してください。");
        }
        render();
        return;
      }
      selected = sel;
      await ensureMovesLoaded();
      render();
    }

    async function ensureMovesLoaded() {
      if (!selected) return;
      const key = selectionKey(selected);
      if (key === movesForKey && validMoves.length > 0) return;

      let url = "/api/legal?";
      if (selected.type === "board") {
        url += `from=${encodeURIComponent(coordToString(selected.x, selected.y))}`;
      } else {
        url += `drop=${encodeURIComponent(selected.kind)}`;
      }
      try {
        const data = await fetchJSON(url);
        validMoves = data.moves || [];
        movesForKey = key;
      } catch (err) {
        setMessage(err.message || String(err));
        validMoves = [];
        movesForKey = "";
      }
    }

    function isValidDestination(coord) {
      return validMoves.some((m) => m.to === coord);
    }

    function createPieceElement(piece) {
      const pieceEl = document.createElement("div");
      pieceEl.className = "piece";
      if (piece.owner === OWNER_TOP) pieceEl.classList.add("gote");
      if (piece.promoted) pieceEl.classList.add("promoted");
      const baseText = kindToText[piece.kind] || "?";
      pieceEl.textContent = piece.promoted ? (piece.kind === "S" ? "全" : piece.kind === "P" ? "と" : baseText) : baseText;
      return pieceEl;
    }

    function updateStatus(view) {
      const statusEl = document.getElementById("status");
      if (!state || !view) {
        statusEl.textContent = "未接続";
        return;
      }
      if (view.checkmate && view.winner) {
        statusEl.textContent = `勝者: ${view.winner}`;
        return;
      }
      const turnText = view.turn === OWNER_BOTTOM ? "先手" : "後手";
      if (!isLiveView()) {
        statusEl.textContent = `棋譜再生中: ${turnText}の手番`;
        if (view.check) {
          statusEl.textContent += "（王手）";
        }
        return;
      }
      if (state.autoPlaying) {
        statusEl.textContent = `AI対局中 (${turnText}の手番)`;
        if (view.check) {
          statusEl.textContent += "（王手）";
        }
        return;
      }
      statusEl.textContent = `${turnText}の手番`;
      if (view.check) {
        statusEl.textContent += "（王手）";
      }
    }

    function setMessage(msg) {
      const el = document.getElementById("message");
      el.textContent = msg || "";
    }

    function updateEngineSelectors() {
      const mapping = state?.engines || {};
      const topSelect = document.getElementById("engine-top");
      const bottomSelect = document.getElementById("engine-bottom");
      if (topSelect) {
        topSelect.value = mapping.top || state?.engine || "random";
      }
      if (bottomSelect) {
        bottomSelect.value = mapping.bottom || "human";
      }
    }

    function updateAutoControls() {
      const btn = document.getElementById("auto-btn");
      if (!btn) return;
      const running = !!state?.autoPlaying;
      btn.textContent = running ? "AI対局停止" : "AI対局開始";
      if (running) {
        btn.disabled = false;
        return;
      }
      const engines = state?.engines || {};
      const ready = engines.bottom && engines.top && engines.bottom !== "human" && engines.top !== "human";
      btn.disabled = !ready;
    }

    async function toggleAutoPlay() {
      if (!state) return;
      const running = !state.autoPlaying;
      try {
        await fetchJSON("/api/auto", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ running, interval_ms: AUTO_INTERVAL_MS })
        });
        await fetchAndRenderState();
        setMessage(running ? "AI対局を開始しました。" : "AI対局を停止しました。");
      } catch (err) {
        setMessage(err.message || String(err));
      }
    }

    function syncAutoPolling(running) {
      if (running) {
        if (autoPollHandle) return;
        autoPollHandle = setInterval(fetchAndRenderState, AUTO_POLL_MS);
      } else if (autoPollHandle) {
        clearInterval(autoPollHandle);
        autoPollHandle = null;
      }
    }

    function timelineLength() {
      if (!state) return 0;
      const historyCount = state.history ? state.history.length : 0;
      return historyCount + 1;
    }

    function clampReviewIndex() {
      if (!state) return;
      const max = timelineLength() - 1;
      if (max < 0) {
        reviewIndex = 0;
        return;
      }
      if (reviewIndex > max) reviewIndex = max;
      if (reviewIndex < 0) reviewIndex = 0;
    }

    function currentReviewIndex() {
      if (!state) return 0;
      const max = timelineLength() - 1;
      if (followLatest) {
        return max;
      }
      const clamped = Math.max(0, Math.min(reviewIndex, max));
      reviewIndex = clamped;
      return clamped;
    }

    function getSnapshotAt(index) {
      if (!state) return null;
      if (index === 0) {
        return state.initial || null;
      }
      const history = state.history || [];
      const entry = history[index - 1];
      return entry ? entry.snapshot : null;
    }

    function getActiveView() {
      if (!state) return null;
      const index = currentReviewIndex();
      if (index === timelineLength() - 1) {
        return state;
      }
      return getSnapshotAt(index) || state;
    }

    function isLiveView() {
      if (!state) return false;
      return followLatest && currentReviewIndex() === timelineLength() - 1;
    }

    function setReviewIndex(index) {
      if (!state) return;
      followLatest = false;
      const max = timelineLength() - 1;
      reviewIndex = Math.max(0, Math.min(index, max));
      selected = null;
      validMoves = [];
      movesForKey = "";
      render();
    }

    function shiftReview(delta) {
      if (!state) return;
      const target = currentReviewIndex() + delta;
      setReviewIndex(target);
    }

    function jumpToLatest() {
      if (!state) return;
      followLatest = true;
      const max = timelineLength() - 1;
      reviewIndex = max < 0 ? 0 : max;
      selected = null;
      validMoves = [];
      movesForKey = "";
      render();
    }

    function renderReviewStatus() {
      const el = document.getElementById("review-status");
      if (!el || !state) return;
      const total = timelineLength();
      if (total <= 1) {
        el.textContent = "";
        el.classList.remove("active");
        return;
      }
      if (isLiveView()) {
        el.textContent = "最新局面を表示中";
        el.classList.remove("active");
        return;
      }
      const index = currentReviewIndex();
      let label = "初期局面";
      if (index > 0) {
        const entry = state.history?.[index - 1];
        if (entry) {
          const turnLabel = entry.player === OWNER_BOTTOM ? "先手" : "後手";
          label = `${index}手目 (${turnLabel} ${entry.move})`;
        }
      }
      el.textContent = `棋譜再生: ${label}`;
      el.classList.add("active");
    }

    function coordToString(x, y) {
      return `${String.fromCharCode("a".charCodeAt(0) + x)}${y + 1}`;
    }

    function selectionKey(sel) {
      if (!sel) return "";
      if (sel.type === "hand") return `hand-${sel.owner}-${sel.kind}`;
      return `board-${sel.owner}-${sel.x}-${sel.y}`;
    }

    async function fetchJSON(url, options = {}) {
      const res = await fetch(url, options);
      const text = await res.text();
      let data = null;
      if (text) {
        try {
          data = JSON.parse(text);
        } catch (_) {
          data = null;
        }
      }
      if (!res.ok) {
        const msg = (data && (data.error || data.message)) || text || res.statusText;
        const err = new Error(msg);
        err.data = data;
        throw err;
      }
      return data;
    }
  </script>
</body>
</html>
